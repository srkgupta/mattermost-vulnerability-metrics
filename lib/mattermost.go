package lib

import (
	"encoding/json"
	"fmt"
	"net/http"
	"os"
	"strings"
	"time"
)

const (
	playbookApi             = "/plugins/playbooks/api/v0/playbooks?team_id=&sort=title&search_term=%s"
	runsApi                 = "/plugins/playbooks/api/v0/runs?page=0&per_page=100&sort=last_status_update_at&direction=desc&participant_or_follower_id=&statuses=InProgress&statuses=Finished&playbook_id=%s"
	channelsApi             = "/api/v4/channels/%s"
	usersApi                = "/api/v4/users/%s"
	submittedPrItem         = "Submit a Pull Request (or) Fix the issue"
	patchReleaseItem        = "Create a Patch Release"
	mergePullRequestItem    = "Merge the Pull Request"
	waitUntilFixReleaseItem = "Wait until fix is released"
	timeFormat              = "2006-01-02 15:04:05"
	lookbackQuarters        = 1
)

var userDetails = make(map[string]string)

type PlaybookResponse struct {
	Items []PlaybookItem
}

type PlaybookItem struct {
	Id string `json:"id"`
}

type RunResponse struct {
	Items []RunItem
}

type RunItem struct {
	Name          string
	Summary       string
	ChannelId     string `json:"channel_id"`
	ReporterId    string `json:"reporter_user_id"`
	CreateAt      int64  `json:"create_at"`
	EndAt         int64  `json:"end_at"`
	CurrentStatus string `json:"current_status"`
	Checklists    []Checklist
}

type Checklist struct {
	Title string
	Items []ChecklistItem
}

type ChecklistItem struct {
	Title         string
	State         string
	StateModified int64 `json:"state_modified"`
}

type Channel struct {
	Header string
}

type User struct {
	FirstName string `json:"first_name"`
	LastName  string `json:"last_name"`
}

func GetPlaybookId() string {
	api := fmt.Sprintf(playbookApi, Env.PlaybookName)
	bodyBytes, resErr := doHTTPRequest(http.MethodGet, Env.MattermostUrl+api, nil)
	if resErr != nil {
		panic(resErr)
	}

	var playbook PlaybookResponse
	err := json.Unmarshal(bodyBytes, &playbook)
	if err != nil {
		fmt.Printf("Error while decoding response while making request to playbooks api, error: %s", err.Error())
		panic(err)
	}
	playbookId := ""
	if len(playbook.Items) > 0 {
		playbookId = playbook.Items[0].Id
	} else {
		fmt.Println("Playbook Id not found for the Security Vulnerability Playbook")
		os.Exit(1)
	}
	return playbookId
}

func getPlaybookRunTime(checklists []Checklist, matchItem string) time.Time {
	found := false
	var t time.Time
	for _, checklist := range checklists {
		for _, checklistItem := range checklist.Items {
			if checklistItem.Title == matchItem {
				if checklistItem.StateModified > 0 {
					runTime := int64(checklistItem.StateModified) / 1000
					t = time.Unix(runTime, 0)
					found = true
					break
				}
			}
		}
		if found {
			break
		}
	}
	return t.UTC()
}

func extractJiraTicketId(title string) string {
	jiraTicketId := ""
	if strings.HasPrefix(title, "MM-") {
		jiraTicketId = strings.Split(title, " ")[0]
		if strings.Contains(jiraTicketId, ":") {
			jiraTicketId = strings.Split(jiraTicketId, ":")[0]
		}
	}
	return jiraTicketId
}

func getUser(userId string) string {
	if val, ok := userDetails[userId]; ok {
		return val
	}
	api := Env.MattermostUrl + fmt.Sprintf(usersApi, userId)
	bodyBytes, resErr := doHTTPRequest(http.MethodGet, api, nil)
	if resErr != nil {
		panic(resErr)
	}
	var response User
	err := json.Unmarshal(bodyBytes, &response)
	if err != nil {
		fmt.Printf("Error while decoding response while making request to playbook runs api, error: %s", err.Error())
		panic(err)
	}
	name := fmt.Sprintf("%s %s", response.FirstName, response.LastName)
	userDetails[userId] = name
	return name
}

func getChannelHeader(channelId string) string {
	api := Env.MattermostUrl + fmt.Sprintf(channelsApi, channelId)
	bodyBytes, resErr := doHTTPRequest(http.MethodGet, api, nil)
	if resErr != nil {
		panic(resErr)
	}
	var response Channel
	err := json.Unmarshal(bodyBytes, &response)
	if err != nil {
		fmt.Printf("Error while decoding response while making request to playbook runs api, error: %s", err.Error())
		panic(err)
	}
	return response.Header
}

func extractPriorityFromChannelHeader(header string) string {
	priority := ""
	if strings.HasPrefix(header, "**SEVERITY:") {
		priority = strings.Split(header, "**SEVERITY:")[1]
		priority = strings.Split(priority, "**")[0]
		priority = strings.TrimSpace(priority)
	}
	return priority
}

func ExportPlaybookRuns(playbookId string) (string, error) {
	api := Env.MattermostUrl + fmt.Sprintf(runsApi, playbookId)
	bodyBytes, resErr := doHTTPRequest(http.MethodGet, api, nil)
	if resErr != nil {
		return "", resErr
	}
	var response RunResponse
	err := json.Unmarshal(bodyBytes, &response)
	if err != nil {
		fmt.Printf("Error while decoding response while making request to playbook runs api, error: %s", err.Error())
		return "", err
	}
	output := "Issue Key,Title,Team,Vulnerability Category,Reporter,Priority,Status,Created At,PR Submitted At,Patched At,Released At,Ended At,Time to submit PR,Time to Patch,Time to Release,Time to Close,Total Time\n"
	for _, item := range response.Items {
		//TODO: Logic to filter records belonging to last N quarters
		jiraId := extractJiraTicketId(item.Name)
		jiraDetails := getJiraTicketDetails(jiraId, true)
		jiraTeam := jiraDetails.Team
		vulnCategory := jiraDetails.VulnCategory
		channelHeader := getChannelHeader(item.ChannelId)
		priority := extractPriorityFromChannelHeader(channelHeader)
		createdAt := time.Unix(item.CreateAt/1000, 0).UTC()
		endedAt := time.Time{}
		prSubmittedAt := getPlaybookRunTime(item.Checklists, submittedPrItem)
		fixedAt := getPlaybookRunTime(item.Checklists, patchReleaseItem)
		reporter := getUser(item.ReporterId)
		releasedAt := getPlaybookRunTime(item.Checklists, waitUntilFixReleaseItem)
		if prSubmittedAt.IsZero() && !fixedAt.IsZero() {
			prSubmittedAt = fixedAt
		}
		if fixedAt.IsZero() {
			fixedAt = getPlaybookRunTime(item.Checklists, mergePullRequestItem)
		}
		if item.CurrentStatus == "Finished" {
			endedAt := time.Unix(item.EndAt/1000, 0).UTC()
			if fixedAt.IsZero() {
				fixedAt = endedAt
			}
			if releasedAt.IsZero() {
				releasedAt = endedAt
			}
		}
		submitPRTime := timeDiff(createdAt, prSubmittedAt)
		patchTime := timeDiff(prSubmittedAt, fixedAt)
		releaseTime := timeDiff(fixedAt, releasedAt)
		closeTime := timeDiff(releasedAt, endedAt)
		totalTime := timeDiff(createdAt, endedAt)
		details := fmt.Sprintf("%s,%s,%s,%s,%s,%s,%s", jiraId, item.Name, jiraTeam, vulnCategory, reporter, priority, item.CurrentStatus)
		details += fmt.Sprintf(",%s,%s,%s,%s,%s", formatTime(createdAt), formatTime(prSubmittedAt), formatTime(fixedAt), formatTime(releasedAt), formatTime(endedAt))
		details += fmt.Sprintf(",%s,%s,%s,%s,%s", submitPRTime, patchTime, releaseTime, closeTime, totalTime)
		output += details + "\n"
	}
	return output, nil
}
